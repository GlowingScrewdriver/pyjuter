#!/bin/env python3

"""
Script to convert a Python source tree to a Jupyter Notebook
and vice-versa.
"""

from nbformat import (
    reads,    # TODO: Import with an alias?
    writes,
    validate,
)
from nbformat.v4 import (
    new_notebook,
    new_code_cell,
)
from collections.abc import Iterable
from collections import defaultdict
from typing import Self

import pyjuter.shims as shims


class Chunk:
    """
    A single code chunk. This can be a part of a file from a Python
    source tree or a cell in a Jupyter Notebook.
    """

    def __init__ (self, source: str, modname: str|None, filename: str):
        self.source = source
        self.modname = modname
        self.filename = filename

    @classmethod
    def from_py (
            cls, source: str, *,
            modname: str|None = None,
            filename: str
        ) -> Self:
        "Construct from Python source chunk"
        res = cls (source, modname, filename)
        return res

    @classmethod
    def from_ipynb (cls, cell) -> Self:
        "Construct from a Jupyter Notebook cell"
        if "pyjuter" not in cell.metadata:
            raise Exception (f"Cell {cell.id} not generated by Pyjuter")
        metadata = cell.metadata.pyjuter

        src = cell.source
        for digest in metadata.shims:
            src = shims.strip_shim (src, digest)
            if src is None:
                raise Exception (f"Cell {cell.id} shim is corrupt!")

        modname, filename = metadata.modname, metadata.filename
        res = cls (src, modname, filename)
        return res

    def as_nb_cell (self) -> dict:
        "Render as a Jupyter Notebook cell"
        if self.modname is not None:
            pre = shims.importable_pre.format (module_name = self.modname)
            post = shims.importable_post
            src = "".join ((
                pre,
                self.source,
                post,
            ))
            cell_shims = (
                shims.digest (pre, mode = "pre"),
                shims.digest (post, mode = "post"),
            )
        else:
            src = self.source
            cell_shims = ()

        return new_pyjuter_code_cell (
            source = src,
            modname = self.modname,
            filename = self.filename,
            shims = cell_shims,
        )

    def as_py (self) -> str:
        "Render as a chunk of Python source"
        return self.source

class Module:
    """
    Abstraction of Python source trees and Jupyter Notebooks.
    """
    # TODO[concept]: distinguish Python module and Pyjuter Module
    chunks: list[Chunk]

    @classmethod
    def from_py (cls, source: str, filename: str) -> Self:
        """
        Construct from Python source code read from `source`.
        """
        res = cls ()
        res.chunks = [
            Chunk.from_py (c, filename = filename)
            for c in split_toplevel_stmts (source)
        ]
        return res

    @classmethod
    def from_ipynb (cls, source: str) -> Self:
        """
        Construct from a Jupyter Notebook read from `source`.
        """
        nb = reads (source, as_version = 4)
        if "pyjuter" not in nb.metadata:
            raise Exception ("Notebook not generated by Pyjuter")

        validate_pyjuter_notebook (nb)

        res = cls ()
        res.metadata = nb ["metadata"]
        res.chunks = [
            Chunk.from_ipynb (cell)
            for cell in nb.cells
            if "pyjuter" in cell.metadata
        ]
        return res

    def to_py (self) -> dict[str, str]:
        """
        Render as Python source.
        """
        file_chunks = defaultdict (list)
        for c in self.chunks:
            if c.filename == "":
                continue
            file_chunks [c.filename].append (c.source)

        return {
            fname: "\n".join (chunks)
            for fname, chunks in file_chunks.items ()
        }

    def to_ipynb (self) -> str:
        """
        Render as Jupyter Notebook.
        """
        nb = new_notebook ()
        nb.cells = [
            new_pyjuter_code_cell (
                source = shims.module_setup_shim,
                modname = "",
                filename = "",
                shims = (),
            ),
            *(
                c.as_nb_cell ()
                for c in self.chunks
            ),
        ]

        nb.metadata = {
            "language_info": {"name": "python"},
            "pyjuter": True
        }

        validate_pyjuter_notebook (nb)
        return writes (nb)

    def inline (self, other: str, modname: str, filename: str):
        """
        Inline `other` into `self`. This entails including all
        of `other`'s chunks in `self` and setting up the import
        shim to allow access to `other`'s contents.
        """
        other_chunks = (
            Chunk.from_py (c, modname = modname, filename = filename)
            for c in split_toplevel_stmts (other)
        )
        self.chunks = [
            *other_chunks,
            *self.chunks,
        ]

def split_toplevel_stmts (source: str) -> Iterable[str]:
    """
    Split the provided Python source into chunks on the basis of
    blank lines between top-level statements.

    The intention is for each chunk to become a cell in a
    Jupyter Notebook.

    `source` is an iterator over lines of the source
    (excluding newline characters).
    An iterator over the resulting chunks (without trailing
    newlines) is returned.
    """
    chunk: list[str] = []
    lastline = None
    for line in source.split ("\n"):
        if line:
            if not line [0].isspace ():
                # This is the beginning of a statement ... ->
                if lastline == "":
                   # -> ... after a blank line
                   yield "\n".join (chunk)
                   chunk = []

        chunk.append (line)
        lastline = line

    # Don't forget the last chunk!
    if chunk:
        yield "\n".join (chunk)

def new_pyjuter_code_cell (*,
    source: str,
    shims: tuple,
    filename: str,
    modname: str
):
    """
    Wrapper around `new_code_cell`.
    Any metadata defined by Pyjuter MUST be initialized here.

    Notes on metadata:
    * `shims` is a record of shims applied to the cell
    * `filename` is the name of the original Python source
       file. It is left empty for cells that only hold
       shim code.
    * `modname` is the module name under which this cell's
      code is accessible. It is non-empty for inlined
      Python sources.
    """
    cell = new_code_cell ()
    cell.source = source
    cell.metadata.pyjuter = {
        "shims": shims,
        "filename": filename,
        "modname": modname,
    }
    return cell

def validate_pyjuter_notebook (nb):
    """
    Validate a Jupyter Notebook generated by Pyjuter.
    """
    validate (nb)
    messages = []

    # Check: this notebook was generated by Pyjuter
    if "pyjuter" not in nb.metadata:
        messages.append ("Notebook: `metadata.pyjuter` missing")

    # Check: each Pyjuter cell has the right metadata
    for cell in nb.cells:
        if "pyjuter" not in cell.metadata:
            continue
        if cell.metadata.pyjuter.keys () != {"shims", "filename", "modname"}:
            messages.append (f"Cell {cell.id}: malformed metadata")

    if messages:
        with open ("err.ipynb", "w") as f:
            f.write (writes (nb))
        e = Exception ("Malformed notebook")
        for m in messages:
            e.add_note (m)
        e.add_note ("Notebook dumped to ./err.ipynb")
        raise (e)
