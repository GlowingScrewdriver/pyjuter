#!/bin/env python3

"""
Script to convert a Python source tree to a Jupyter Notebook
and vice-versa.
"""

from nbformat import (
    reads,    # TODO: Import with an alias?
    writes,
    validate,
)
from nbformat.v4 import (
    new_notebook,
    new_code_cell,
)
from collections.abc import Iterable
from typing import Self

import pyjuter.shims as shims


class Chunk:
    """
    A single code chunk. This can be a part of a file from a Python
    source tree or a cell in a Jupyter Notebook.
    """

    def __init__ (self, source: str, modname: str|None, *, importable: bool):
        self.source = source
        if importable:
            assert modname is not None
        self.modname = modname
        self.importable = importable

    @classmethod
    def from_py (cls, source: str, modname: str|None = None, *, importable = False) -> Self:
        "Construct from Python source chunk"
        res = cls (source, modname, importable = importable)
        return res

    @classmethod
    def from_ipynb (cls, cell) -> Self:
        "Construct from a Jupyter Notebook cell"
        if "pyjuter" not in cell.metadata:
            raise Exception (f"Cell {cell.id} not generated by Pyjuter")
        metadata = cell.metadata.pyjuter

        src = cell.source
        for digest in metadata.shims:
            src = shims.strip_shim (src, digest)
            if src is None:
                raise Exception (f"Cell {cell.id} shim is corrupt!")

        modname, importable = metadata.modname, metadata.importable
        res = cls (src, modname, importable = importable)
        return res

    def as_nb_cell (self) -> dict:
        "Render as a Jupyter Notebook cell"
        cell = new_pyjuter_code_cell ()

        if self.importable:
            pre = shims.importable_pre.format (module_name = self.modname)
            post = shims.importable_post
            src = "".join ((
                pre,
                self.source,
                post,
            ))
            cell.metadata.pyjuter.shims = [
                shims.digest (pre, mode = "pre"),
                shims.digest (post, mode = "post"),
            ]
            cell.metadata.pyjuter.importable = True
            cell.metadata.pyjuter.modname = self.modname
        else:
            src = self.source

        cell.source = src
        return cell

    def as_py (self) -> str:
        "Render as a chunk of Python source"
        return self.source

class Module:
    """
    Abstraction of Python source trees and Jupyter Notebooks.
    """
    # TODO[concept]: distinguish Python module and Pyjuter Module
    chunks: list[Chunk]
    metadata: dict

    @classmethod
    def from_py (cls, source: str) -> Self:
        """
        Construct from Python source code read from `source`.
        """
        res = cls ()
        res.metadata = {
            "language_info": {
                "name": "python",
            }
        }
        res.chunks = [
            Chunk.from_py (c)
            for c in split_toplevel_stmts (source)
        ]
        return res

    @classmethod
    def from_ipynb (cls, source: str) -> Self:
        """
        Construct from a Jupyter Notebook read from `source`.
        """
        nb = reads (source, as_version = 4)
        res = cls ()
        res.metadata = nb ["metadata"]
        res.chunks = [
            # TODO: Verify cell type
            Chunk.from_ipynb (cell)
            for cell in nb.cells
        ]
        return res

    def to_py (self) -> str:
        """
        Render as Python source.
        """
        return "\n".join ((
            c.as_py ()
            for c in self.chunks
        ))

    def to_ipynb (self) -> str:
        """
        Render as Jupyter Notebook.
        """
        nb = new_notebook ()
        cells = (
            c.as_nb_cell ()
            for c in self.chunks
        )
        nb.cells = [
            new_pyjuter_code_cell (source = shims.module_setup_shim),
            *cells,
        ]

        validate (nb)
        return writes (nb)

    def inline (self, other: str, modname: str):
        """
        Inline `other` into `self`. This entails including all
        of `other`'s chunks in `self` and setting up the import
        shim to allow access to `other`'s contents.
        """
        other_chunks = (
            Chunk.from_py (c, modname = modname, importable = True)
            for c in split_toplevel_stmts (other)
        )
        self.chunks = [
            *other_chunks,
            *self.chunks,
        ]

def split_toplevel_stmts (source: str) -> Iterable[str]:
    """
    Split the provided Python source into chunks on the basis of
    blank lines between top-level statements.

    The intention is for each chunk to become a cell in a
    Jupyter Notebook.

    `source` is an iterator over lines of the source
    (excluding newline characters).
    An iterator over the resulting chunks (without trailing
    newlines) is returned.
    """
    chunk: list[str] = []
    lastline = None
    for line in source.split ("\n"):
        if line:
            if not line [0].isspace ():
                # This is the beginning of a statement ... ->
                if lastline == "":
                   # -> ... after a blank line
                   yield "\n".join (chunk)
                   chunk = []

        chunk.append (line)
        lastline = line

    # Don't forget the last chunk!
    if chunk:
        yield "\n".join (chunk)

def new_pyjuter_code_cell (*pargs, **kargs):
    """
    Wrapper around `new_code_cell`.
    Any metadata defined by Pyjuter MUST be initialized here.
    """
    cell = new_code_cell (*pargs, **kargs)
    cell.metadata.pyjuter = {
        "shims": (),
        "importable": False,
        "modname": None,
    }
    return cell
